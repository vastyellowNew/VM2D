/*!
\file
\brief Заголовочный файл с описанием класса Wake
\author Марчевский Илья Константинович
\author Кузьмина Ксения Сергеевна
\author Рятина Евгения Павловна
\version 1.0
\date 1 декабря 2017 г.
*/

#ifndef WAKE_H
#define WAKE_H

#include "Airfoil.h"
#include "Parallel.h"

/*!
\brief Класс, опеделяющий вихревой след (пелену)
\author Марчевский Илья Константинович
\author Кузьмина Ксения Сергеевна
\author Рятина Евгения Павловна
\version 1.0
\date 1 декабря 2017 г.
*/
class Wake
{
public:
	/// Список вихревых элементов
	std::vector<Vortex2D> vtx;
	
	/// Количество вихрей в пелене
	int nv;	

	/// Константная ссылка на параметры дискретизации вихревого следа
	const WakeDiscretizationProperties& param;
	
	/// Константная ссылка на параметры исполнения в параллельном режиме
	const Parallel& parallel;
	
	/// \brief Конструктор инициализации
	///
	/// \param[in] param_ константная ссылка на параметры дискретизации вихревого следа
	/// \param[in] parallel_ константная ссылка на параметры исполнения в параллельном режиме
	Wake(const WakeDiscretizationProperties& param_, const Parallel& parallel_) 
		: param(param_), nv(0), parallel(parallel_) { };
	
	/// Деструктор
	~Wake(){ };

	/// \brief Считывание вихревого следа из файла 
	/// 
	/// \param[in] dir константная ссылка на строку, задающую каталог, где лежит файл с вихревым следом
	void ReadFromFile(const std::string& dir);
	
	/// \brief Сохранение вихревого следа в файл 
	/// 
	/// \param[in] dir константная ссылка на строку, задающую каталог, куда сохранять файл с вихревым следом
	/// \param[in] step номер кадра для сохранения
	void SaveKadr(const std::string& dir, int step) const;

	/// \brief MPI-синхронизация вихревого следа
	///
	/// \todo В целях оптимизации можно подумать над .reserve()
	///
	/// Рассылка следа на все процессоры локальной группы процессоров, занятых решением данной задачи
	void WakeSinchronize();  

	/// \brief Проверка пересечения вихрями следа профиля при перемещении
	///
	/// Исполняется сразу для всех вихрей в пелене, осуществляет проверку для отдельного профиля
	/// 
	/// \param[in] newPos константная ссылка на вектор из новых положени	й вихрей в вихревом следе
	/// \param[in] afl константная ссылка на контролируемый профиль
	/// \return вектор, длина которого равна числу панелей на профиле, и который содержит циркуляции, проникшие в профиль через соответствующие панели
	/// \warning Использует OMP, MPI
	std::vector<double> Inside(const std::vector<Point2D>& newPos, const Airfoil& afl);
};

#endif
